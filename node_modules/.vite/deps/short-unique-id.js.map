{
  "version": 3,
  "sources": ["../../short-unique-id/src/index.ts", "dep:short-unique-id"],
  "sourcesContent": ["// @module ShortUniqueId\n\n// Copyright 2017-2021 the Short Unique ID authors. All rights reserved. Apache 2.0 license.\n\n// @ts-ignore\nimport {version} from '../package.json';\n\ninterface ShortUniqueIdRanges {\n  [k: string]: [number, number];\n};\n\ntype defaultDictionaries = 'number' | 'alpha' | 'alpha_lower' | 'alpha_upper' | 'alphanum' | 'alphanum_lower' | 'alphanum_upper' | 'hex';\n\n/**\n * ```js\n * {\n *   dictionary: ['z', 'a', 'p', 'h', 'o', 'd', ...],\n *   shuffle: false,\n *   debug: false,\n *   length: 6,\n * }\n * ```\n */\nexport interface ShortUniqueIdOptions {\n  /** User-defined character dictionary */\n  dictionary: string[] | defaultDictionaries;\n\n  /** If true, sequentialUUID use the dictionary in the given order */\n  shuffle: boolean;\n\n  /** If true the instance will console.log useful info */\n  debug: boolean;\n\n  /** From 1 to infinity, the length you wish your UUID to be */\n  length: number;\n};\n\n/**\n * 6 was chosen as the default UUID length since for most cases\n * it will be more than aptly suitable to provide millions of UUIDs\n * with a very low probability of producing a duplicate UUID.\n *\n * For example, with a dictionary including digits from 0 to 9,\n * as well as the alphabet from a to z both in UPPER and lower case,\n * the probability of generating a duplicate in 1,000,000 rounds\n * is ~0.00000002, or about 1 in 50,000,000.\n */\nexport const DEFAULT_UUID_LENGTH: number = 6;\n\nconst DEFAULT_OPTIONS: ShortUniqueIdOptions = {\n  dictionary: 'alphanum',\n  shuffle: true,\n  debug: false,\n  length: DEFAULT_UUID_LENGTH,\n};\n\n/**\n * Generate random or sequential UUID of any length.\n *\n * ### Use as module\n *\n * ```js\n * // Deno (web module) Import\n * import ShortUniqueId from 'https://cdn.jsdelivr.net/npm/short-unique-id@latest/src/index.ts';\n *\n * // ES6 / TypeScript Import\n * import ShortUniqueId from 'short-unique-id';\n *\n * //or Node.js require\n * const ShortUniqueId = require('short-unique-id');\n *\n * //Instantiate\n * const uid = new ShortUniqueId();\n *\n * // Random UUID\n * console.log(uid());\n *\n * // Sequential UUID\n * console.log(uid.seq());\n * ```\n *\n * ### Use in browser\n *\n * ```html\n * <!-- Import -->\n * <script src=\"https://cdn.jsdelivr.net/npm/short-unique-id@latest/dist/short-unique-id.min.js\"></script>\n *\n * <!-- Usage -->\n * <script>\n *   // Instantiate\n *   var uid = new ShortUniqueId();\n *\n *   // Random UUID\n *   document.write(uid());\n *\n *   // Sequential UUID\n *   document.write(uid.seq());\n * </script>\n * ```\n *\n * ### Options\n *\n * Options can be passed when instantiating `uid`:\n *\n * ```js\n * const options = { ... };\n *\n * const uid = new ShortUniqueId(options);\n * ```\n *\n * For more information take a look at the [ShortUniqueIdOptions type definition](/interfaces/shortuniqueidoptions.html).\n */\nexport default class ShortUniqueId extends Function {\n  static default: typeof ShortUniqueId = ShortUniqueId;\n\n  public counter: number;\n  public debug: boolean;\n  public dict: string[];\n  public version: string;\n  public dictIndex: number = 0;\n  public dictRange: number[] =[];\n  public lowerBound: number = 0;\n  public upperBound: number = 0;\n  public dictLength: number = 0;\n  public uuidLength: number;\n\n  protected _digit_first_ascii: number = 48;\n  protected _digit_last_ascii: number = 58;\n  protected _alpha_lower_first_ascii: number = 97;\n  protected _alpha_lower_last_ascii: number = 123;\n  protected _hex_last_ascii: number = 103;\n  protected _alpha_upper_first_ascii: number = 65;\n  protected _alpha_upper_last_ascii: number = 91;\n\n  protected _number_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n  };\n\n  protected _alpha_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alpha_lower_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alpha_upper_dict_ranges: ShortUniqueIdRanges = {\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_lower_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alphanum_upper_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _hex_dict_ranges: ShortUniqueIdRanges = {\n    decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n    alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii],\n  };\n\n  /* tslint:disable consistent-return */\n  protected log = (...args: any[]): void => {\n    const finalArgs = [...args];\n    finalArgs[0] = `[short-unique-id] ${args[0]}`;\n    /* tslint:disable no-console */\n    if (this.debug === true) {\n      if (typeof console !== 'undefined' && console !== null) {\n        return console.log(...finalArgs);\n      }\n    }\n    /* tslint:enable no-console */\n  };\n  /* tslint:enable consistent-return */\n\n  /** Change the dictionary after initialization. */\n  setDictionary = (dictionary: string[] | defaultDictionaries, shuffle?: boolean): void => {\n    let finalDict: string[];\n\n    if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n      finalDict = dictionary as string[];\n    } else {\n      finalDict = [];\n\n      let i;\n\n      this.dictIndex = i = 0;\n\n      const rangesName = `_${dictionary as defaultDictionaries}_dict_ranges`;\n      const ranges: ShortUniqueIdRanges = this[rangesName as keyof ShortUniqueId];\n\n      Object.keys(ranges).forEach((rangeType) => {\n        const rangeTypeKey = rangeType;\n\n        this.dictRange = ranges[rangeTypeKey];\n\n        this.lowerBound = this.dictRange[0];\n        this.upperBound = this.dictRange[1];\n\n        for (\n          this.dictIndex = i = this.lowerBound;\n          this.lowerBound <= this.upperBound ? i < this.upperBound : i > this.upperBound;\n          this.dictIndex = this.lowerBound <= this.upperBound ? i += 1 : i -= 1\n        ) {\n          finalDict.push(String.fromCharCode(this.dictIndex));\n        }\n      });\n    }\n\n    if (shuffle) {\n      // Shuffle Dictionary to remove selection bias.\n      const PROBABILITY = 0.5;\n      finalDict = finalDict.sort(() => Math.random() - PROBABILITY);\n    }\n\n    this.dict = finalDict;\n\n    // Cache Dictionary Length for future usage.\n    this.dictLength = this.dict.length;// Resets internal counter.\n    this.counter = 0;\n  };\n\n  seq = (): string => {\n    return this.sequentialUUID();\n  };\n\n  /**\n   * Generates UUID based on internal counter that's incremented after each ID generation.\n   * @alias `const uid = new ShortUniqueId(); uid.seq();`\n   */\n  sequentialUUID = (): string => {\n    let counterDiv: number;\n    let counterRem: number;\n    let id: string = '';\n\n    counterDiv = this.counter;\n\n    do {\n      counterRem = counterDiv % this.dictLength;\n      counterDiv = Math.trunc(counterDiv / this.dictLength);\n      id += this.dict[counterRem];\n    } while (counterDiv !== 0);\n\n    this.counter += 1;\n\n    return id;\n  };\n\n  /**\n   * Generates UUID by creating each part randomly.\n   * @alias `const uid = new ShortUniqueId(); uid(uuidLength: number);`\n   */\n  randomUUID = (uuidLength: number = this.uuidLength || DEFAULT_UUID_LENGTH): string => {\n    let id: string;\n    let randomPartIdx: number;\n    let j: number;\n\n    if ((uuidLength === null || typeof uuidLength === 'undefined') || uuidLength < 1) {\n      throw new Error('Invalid UUID Length Provided');\n    }\n\n    const isPositive = uuidLength >= 0;\n\n    // Generate random ID parts from Dictionary.\n    id = '';\n    for (\n      j = 0;\n      j < uuidLength;\n      j += 1\n    ) {\n      randomPartIdx = parseInt(\n        (Math.random() * this.dictLength).toFixed(0),\n        10,\n      ) % this.dictLength;\n      id += this.dict[randomPartIdx];\n    }\n\n    // Return random generated ID.\n    return id;\n  };\n\n  /**\n   * Calculates total number of possible UUIDs.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs\n   * - `n` is the number of unique characters in the dictionary\n   * - `l` is the UUID length\n   *\n   * Then `H` is defined as `n` to the power of `l`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El)\n   *\n   * This function returns `H`.\n   */\n  availableUUIDs = (uuidLength: number = this.uuidLength): number => {\n    return parseFloat(\n      Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0),\n    );\n  };\n\n  /**\n   * Calculates approximate number of hashes before first collision.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - the expected number of values we have to choose before finding the\n   * first collision can be expressed as the quantity `Q(H)`\n   *\n   * Then `Q(H)` can be approximated as the square root of the product of half\n   * of pi times `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D)\n   *\n   * This function returns `Q(H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   */\n  approxMaxBeforeCollision = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    return parseFloat(\n      Math.sqrt((Math.PI / 2) * rounds).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculates probability of generating duplicate UUIDs (a collision) in a\n   * given number of UUID generation rounds.\n   *\n   * Given that:\n   *\n   * - `r` is the maximum number of times that `randomUUID()` will be called,\n   * or better said the number of _rounds_\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   *\n   * Then the probability of collision `p(r; H)` can be approximated as the result\n   * of dividing the square root of the product of half of pi times `r` by `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D)\n   *\n   * This function returns `p(r; H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   *\n   * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n   * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n   */\n  collisionProbability = (\n    rounds: number = this.availableUUIDs(this.uuidLength),\n    uuidLength: number = this.uuidLength,\n  ): number => {\n    return parseFloat(\n      (\n        this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)\n      ).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n   * dictionary and chosen UUID length.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - `Q(H)` is the approximate number of hashes before first collision,\n   * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n   *\n   * Then `uniqueness` can be expressed as the additive inverse of the probability of\n   * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n   * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n   *\n   * ![](https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D)\n   *\n   * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n   * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n   */\n  uniqueness = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    const score = parseFloat(\n      (1 - (\n        this.approxMaxBeforeCollision(rounds) / rounds\n      )).toFixed(20),\n    );\n    return (\n      score > 1\n    ) ? (\n      1\n    ) : (\n      (score < 0) ? 0 : score\n    );\n  };\n\n  /**\n   * Return the version of this module.\n   */\n  getVersion = (): string => {\n    return this.version;\n  };\n\n  /**\n   * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  stamp = (finalLength: number): string => {\n    if (typeof finalLength !== 'number' || finalLength < 10) {\n      throw new Error('Param finalLength must be number greater than 10');\n    }\n\n    const hexStamp = Math.floor(+new Date() / 1000).toString(16);\n\n    const idLength = finalLength - 9;\n\n    const rndIdx = Math.round(Math.random() * ((idLength > 15) ? 15 : idLength));\n\n    const id = this.randomUUID(idLength);\n\n    return `${id.substr(0, rndIdx)}${hexStamp}${id.substr(rndIdx)}${rndIdx.toString(16)}`;\n  };\n\n  /**\n   * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  parseStamp = (stamp: string): Date => {\n    if (stamp.length < 10) {\n      throw new Error('Stamp length invalid');\n    }\n\n    const rndIdx = parseInt(stamp.substr(stamp.length - 1, 1), 16);\n\n    return new Date(parseInt(stamp.substr(rndIdx, 8), 16) * 1000);\n  };\n\n  constructor(argOptions: Partial<ShortUniqueIdOptions> = {}) {\n    super();\n\n    const options: ShortUniqueIdOptions = {\n      ...DEFAULT_OPTIONS,\n      ...argOptions as Partial<ShortUniqueIdOptions>,\n    };\n\n    this.counter = 0;\n    this.debug = false;\n    this.dict = [];\n    this.version = version;\n\n    const {\n      dictionary,\n      shuffle,\n      length,\n    } = options;\n\n    this.uuidLength = length;\n\n    this.setDictionary(dictionary, shuffle);\n\n    this.debug = options.debug;\n    this.log(this.dict);\n    this.log((`Generator instantiated with Dictionary Size ${this.dictLength}`));\n\n    return new Proxy(this, {\n      apply: (target, that, args) => this.randomUUID(...args),\n    });\n  }\n}\n", "export default require(\"./node_modules/short-unique-id/dist/short-unique-id.js\");"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,UAAA,cAAA,CAAA;AAAA,eAAA,aAAA;QAAA,qBAAA,MAAA;QAAA,SAAA,MAAAA;MAAA,CAAA;;AA+CO,UAAM,sBAA8B;AAE3C,UAAM,kBAAwC;QAC5C,YAAY;QACZ,SAAS;QACT,OAAO;QACP,QAAQ;MAAA;AA2DV,UAAA,iBAAA,cAA2C,SAAS;QAgWlD,YAAY,aAA4C,CAAA,GAAI;AAC1D,gBAAA;AA1VK,eAAA,YAAoB;AACpB,eAAA,YAAqB,CAAA;AACrB,eAAA,aAAqB;AACrB,eAAA,aAAqB;AACrB,eAAA,aAAqB;AAGlB,eAAA,qBAA6B;AAC7B,eAAA,oBAA4B;AAC5B,eAAA,2BAAmC;AACnC,eAAA,0BAAkC;AAClC,eAAA,kBAA0B;AAC1B,eAAA,2BAAmC;AACnC,eAAA,0BAAkC;AAElC,eAAA,sBAA2C;YACnD,QAAQ,CAAC,KAAK,oBAAoB,KAAK,iBAAA;UAAA;AAG/B,eAAA,qBAA0C;YAClD,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;YAChD,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,2BAAgD;YACxD,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,2BAAgD;YACxD,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,wBAA6C;YACrD,QAAQ,CAAC,KAAK,oBAAoB,KAAK,iBAAA;YACvC,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;YAChD,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,8BAAmD;YAC3D,QAAQ,CAAC,KAAK,oBAAoB,KAAK,iBAAA;YACvC,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,8BAAmD;YAC3D,QAAQ,CAAC,KAAK,oBAAoB,KAAK,iBAAA;YACvC,WAAW,CAAC,KAAK,0BAA0B,KAAK,uBAAA;UAAA;AAGxC,eAAA,mBAAwC;YAChD,WAAW,CAAC,KAAK,oBAAoB,KAAK,iBAAA;YAC1C,aAAa,CAAC,KAAK,0BAA0B,KAAK,eAAA;UAAA;AAI1C,eAAA,MAAM,IAAI,SAAsB;AACxC,kBAAM,YAAY,CAAC,GAAG,IAAA;AACtB,sBAAU,KAAK,qBAAqB,KAAK;AAEzC,gBAAI,KAAK,UAAU,MAAM;AACvB,kBAAI,OAAO,YAAY,eAAe,YAAY,MAAM;AACtD,uBAAO,QAAQ,IAAI,GAAG,SAAA;cAAA;YAAA;UAAA;AAQ5B,eAAA,gBAAgB,CAACC,aAA4CC,aAA4B;AACvF,gBAAI;AAEJ,gBAAID,eAAc,MAAM,QAAQA,WAAA,KAAeA,YAAW,SAAS,GAAG;AACpE,0BAAYA;YAAA,OACP;AACL,0BAAY,CAAA;AAEZ,kBAAI;AAEJ,mBAAK,YAAY,IAAI;AAErB,oBAAM,aAAa,IAAIA;AACvB,oBAAM,SAA8B,KAAK;AAEzC,qBAAO,KAAK,MAAA,EAAQ,QAAQ,CAAC,cAAc;AACzC,sBAAM,eAAe;AAErB,qBAAK,YAAY,OAAO;AAExB,qBAAK,aAAa,KAAK,UAAU;AACjC,qBAAK,aAAa,KAAK,UAAU;AAEjC,qBACE,KAAK,YAAY,IAAI,KAAK,YAC1B,KAAK,cAAc,KAAK,aAAa,IAAI,KAAK,aAAa,IAAI,KAAK,YACpE,KAAK,YAAY,KAAK,cAAc,KAAK,aAAa,KAAK,IAAI,KAAK,GACpE;AACA,4BAAU,KAAK,OAAO,aAAa,KAAK,SAAA,CAAA;gBAAA;cAAA,CAAA;YAAA;AAK9C,gBAAIC,UAAS;AAEX,oBAAM,cAAc;AACpB,0BAAY,UAAU,KAAK,MAAM,KAAK,OAAA,IAAW,WAAA;YAAA;AAGnD,iBAAK,OAAO;AAGZ,iBAAK,aAAa,KAAK,KAAK;AAC5B,iBAAK,UAAU;UAAA;AAGjB,eAAA,MAAM,MAAc;AAClB,mBAAO,KAAK,eAAA;UAAA;AAOd,eAAA,iBAAiB,MAAc;AAC7B,gBAAI;AACJ,gBAAI;AACJ,gBAAI,KAAa;AAEjB,yBAAa,KAAK;AAElB,eAAG;AACD,2BAAa,aAAa,KAAK;AAC/B,2BAAa,KAAK,MAAM,aAAa,KAAK,UAAA;AAC1C,oBAAM,KAAK,KAAK;YAAA,SACT,eAAe;AAExB,iBAAK,WAAW;AAEhB,mBAAO;UAAA;AAOT,eAAA,aAAa,CAAC,aAAqB,KAAK,cAAc,wBAAgC;AACpF,gBAAI;AACJ,gBAAI;AACJ,gBAAI;AAEJ,gBAAK,eAAe,QAAQ,OAAO,eAAe,eAAgB,aAAa,GAAG;AAChF,oBAAM,IAAI,MAAM,8BAAA;YAAA;AAGlB,kBAAM,aAAa,cAAc;AAGjC,iBAAK;AACL,iBACE,IAAI,GACJ,IAAI,YACJ,KAAK,GACL;AACA,8BAAgB,UACb,KAAK,OAAA,IAAW,KAAK,YAAY,QAAQ,CAAA,GAC1C,EAAA,IACE,KAAK;AACT,oBAAM,KAAK,KAAK;YAAA;AAIlB,mBAAO;UAAA;AAkBT,eAAA,iBAAiB,CAAC,aAAqB,KAAK,eAAuB;AACjE,mBAAO,WACL,KAAK,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,IAAA,CAAA,EAAO,QAAQ,UAAA,EAAY,QAAQ,CAAA,CAAA;UAAA;AAuBjE,eAAA,2BAA2B,CAAC,SAAiB,KAAK,eAAe,KAAK,UAAA,MAAwB;AAC5F,mBAAO,WACL,KAAK,KAAM,KAAK,KAAK,IAAK,MAAA,EAAQ,QAAQ,EAAA,CAAA;UAAA;AA2B9C,eAAA,uBAAuB,CACrB,SAAiB,KAAK,eAAe,KAAK,UAAA,GAC1C,aAAqB,KAAK,eACf;AACX,mBAAO,YAEH,KAAK,yBAAyB,MAAA,IAAU,KAAK,eAAe,UAAA,GAC5D,QAAQ,EAAA,CAAA;UAAA;AAwBd,eAAA,aAAa,CAAC,SAAiB,KAAK,eAAe,KAAK,UAAA,MAAwB;AAC9E,kBAAM,QAAQ,YACX,IACC,KAAK,yBAAyB,MAAA,IAAU,QACvC,QAAQ,EAAA,CAAA;AAEb,mBACE,QAAQ,IAER,IAEC,QAAQ,IAAK,IAAI;UAAA;AAOtB,eAAA,aAAa,MAAc;AACzB,mBAAO,KAAK;UAAA;AAed,eAAA,QAAQ,CAAC,gBAAgC;AACvC,gBAAI,OAAO,gBAAgB,YAAY,cAAc,IAAI;AACvD,oBAAM,IAAI,MAAM,kDAAA;YAAA;AAGlB,kBAAM,WAAW,KAAK,MAAM,CAAC,IAAI,KAAA,IAAS,GAAA,EAAM,SAAS,EAAA;AAEzD,kBAAM,WAAW,cAAc;AAE/B,kBAAM,SAAS,KAAK,MAAM,KAAK,OAAA,KAAa,WAAW,KAAM,KAAK,SAAA;AAElE,kBAAM,KAAK,KAAK,WAAW,QAAA;AAE3B,mBAAO,GAAG,GAAG,OAAO,GAAG,MAAA,IAAU,WAAW,GAAG,OAAO,MAAA,IAAU,OAAO,SAAS,EAAA;UAAA;AAelF,eAAA,aAAa,CAAC,UAAwB;AACpC,gBAAI,MAAM,SAAS,IAAI;AACrB,oBAAM,IAAI,MAAM,sBAAA;YAAA;AAGlB,kBAAM,SAAS,SAAS,MAAM,OAAO,MAAM,SAAS,GAAG,CAAA,GAAI,EAAA;AAE3D,mBAAO,IAAI,KAAK,SAAS,MAAM,OAAO,QAAQ,CAAA,GAAI,EAAA,IAAM,GAAA;UAAA;AAMxD,gBAAM,UAAgC,eAAA,eAAA,CAAA,GACjC,eAAA,GACA,UAAA;AAGL,eAAK,UAAU;AACf,eAAK,QAAQ;AACb,eAAK,OAAO,CAAA;AACZ,eAAK,UAAU;AAEf,gBAAM;YACJ;YACA;YACA;UAAA,IACE;AAEJ,eAAK,aAAa;AAElB,eAAK,cAAc,YAAY,OAAA;AAE/B,eAAK,QAAQ,QAAQ;AACrB,eAAK,IAAI,KAAK,IAAA;AACd,eAAK,IAAK,+CAA+C,KAAK,YAAA;AAE9D,iBAAO,IAAI,MAAM,MAAM;YACrB,OAAO,CAAC,QAAQ,MAAM,SAAS,KAAK,WAAW,GAAG,IAAA;UAAA,CAAA;QAAA;MAAA;AA5XxD,UAAAF,iBAAA;AAAA,MAAAA,eACS,UAAgC;;;;;;;;ACjHzC,IAAO,0BAAQ;",
  "names": ["ShortUniqueId", "dictionary", "shuffle"]
}
